---
lp: 4106
title: Threshold Lamport Protocol
description: 2-round, no-reconstruction threshold Lamport signatures using additive MPC
author: Lux Core Team (@luxfi)
discussions-to: https://github.com/luxfi/lps/discussions/4106
status: Draft
type: Standards Track
category: Core
created: 2024-12-26
requires: 4105
---

## Abstract

This LP specifies a threshold signing protocol for Lamport one-time signatures that achieves a critical security property: **no node ever reconstructs a Lamport preimage**. The protocol uses additive MPC to produce signatures where preimages emerge only as the sum of masked contributions from t-of-n parties, completing in exactly 2 rounds without requiring coordinator trust.

## Motivation

LP-4105 defines Lamport OTS for Lux Safe but assumes a single signer. Production deployments require threshold control where:

1. **No single point of failure**: T-of-N parties must cooperate
2. **No trusted coordinator**: Any party can aggregate without learning secrets
3. **No key reconstruction**: Preimages must never exist at any single node
4. **Permissionless**: Validators need not know each other in advance

Traditional threshold schemes (Shamir, Feldman VSS) reconstruct secrets at a coordinator, creating a security vulnerability. This LP specifies a Ringtail-equivalent protocol where secrets emerge only in the final public signature.

## Specification

### Notation

| Symbol | Description |
|--------|-------------|
| `n` | Total number of parties |
| `t` | Threshold (minimum parties required) |
| `i` | Bit position index (0..255) |
| `b` | Bit value (0 or 1) |
| `j` | Party index (1..n) |
| `r[j][i][b]` | Party j's random contribution for position i, value b |
| `H()` | keccak256 hash function |
| `PK[i][b]` | Public key element for position i, value b |
| `sig[i]` | Signature element for position i |

### Security Goals

| Requirement | Mechanism |
|-------------|-----------|
| No reconstruction | Additive masking—sum computed in MPC |
| 2 rounds | Commit + masked reveal |
| No coordinator trust | Any ≥ t parties can complete |
| Permissionless | Shares generated independently |
| Public coordination | Blockchain as bulletin board |
| Quantum safe | Hash-based only |
| Standard verification | Normal Lamport verifier |

### Protocol Phases

#### Phase 0: Setup (One-Time Per Key)

For each bit position `i ∈ [0..255]` and bit value `b ∈ {0,1}`:

1. Each party `j` independently samples:
   ```
   r[j][i][b] ← random(32 bytes)
   ```

2. Parties execute MPC to compute public key without revealing shares:
   ```
   PK[i][b] = H( Σⱼ r[j][i][b] )
   ```

3. Each party stores only their own `r[j][*][*]` values.

**Security property**: No party knows:
- The sum `Σⱼ r[j][i][b]`
- Any other party's `r[k][i][b]` where `k ≠ j`
- Any complete preimage

#### Phase 1: Commit (Message-Independent)

When a signing session begins:

1. Coordinator broadcasts `sessionId` and transaction hash `txHash`

2. Each participating party `j` computes and broadcasts:
   ```
   Commit[j] = H(sessionId || H(r[j][*][*]) || nonce[j])
   ```

3. Chain locks participation when `≥ t` commitments received

**Properties**:
- Freezes participant set before message revealed
- Prevents equivocation (same party, different messages)
- Publicly verifiable on-chain

#### Phase 2: Masked Contribution (Message-Dependent)

After commitments locked and message `m` finalized:

1. For each bit position `i`, let `b = bit(m, i)`

2. Each party `j` sends to MPC:
   ```
   contribution[j][i] = r[j][i][b]
   ```

3. Contributions are:
   - Encrypted to MPC nodes, OR
   - Sent via pairwise secure channels
   - **Never published in plaintext**

**Security property**: Each `contribution[j][i]` alone is uniformly random and reveals nothing about the final signature.

#### Phase 3: Secure Aggregation

The MPC computes for each bit position `i`:

```
sig[i] = Σⱼ contribution[j][i]   (mod 2²⁵⁶)
```

**Critical constraint**: This summation MUST be performed such that no single party learns:
- All input contributions
- The intermediate sum
- The final `sig[i]` before publication

Implementation options:
1. **Full MPC**: Use standard secure addition protocol
2. **Pairwise masking**: Each pair exchanges masks that cancel in sum
3. **Threshold homomorphic**: Additively homomorphic encryption with threshold decryption

#### Phase 4: Signature Publication

The complete Lamport signature is published:

```
Signature = [sig[0], sig[1], ..., sig[255]]
```

This is the **first and only time** any preimage value appears.

**Verification** (standard Lamport):
```
∀i: H(sig[i]) == PK[i][bit(m, i)]
```

### Message Format

For Lux Safe integration, the signed message includes domain separation:

```solidity
message = keccak256(abi.encodePacked(
    bytes32(safeTxHash),
    bytes32(nextPKH),
    address(module),
    uint256(chainId)
))
```

Where:
- `safeTxHash`: Safe transaction hash
- `nextPKH`: Hash of next public key (for rotation)
- `module`: LamportThreshold module address
- `chainId`: Chain ID (replay protection)

### Key Rotation

Each signature commits to the next public key:

1. **Pre-generate**: Before signing, parties generate `r'[j][i][b]` for next key
2. **Commit next PKH**: Include `nextPKH = H(nextPK)` in signed message
3. **Atomic rotation**: On-chain contract updates to `nextPKH` after verification

```
Sign(m, nextPKH) → Signature
Verify(Signature, PK, m) → true
Contract.currentPKH = nextPKH
```

### Implementation Requirements

#### MPC Node Requirements

Each MPC node MUST:

1. Store only its own `r[j][*][*]` shares
2. Delete used shares immediately after signing
3. Never log or persist contribution values
4. Use authenticated encryption for all communication

#### On-Chain Contract Requirements

The verifier contract:

1. MUST use standard Lamport verification (LP-4105 compatible)
2. MUST enforce key rotation via `nextPKH` commitment
3. MUST include domain separation (chainId, module address)
4. SHOULD support emergency key revocation

## Rationale

### Why Additive MPC Instead of Shamir?

Shamir secret sharing requires reconstruction at some point:

```
secret = Σ lagrange[i] * share[i]
```

This means *someone* learns the secret. With additive MPC:

```
output = Σ contribution[i]
```

The sum is computed *inside* MPC—no party ever holds the complete preimage.

### Why 2 Rounds?

| Round | Purpose |
|-------|---------|
| 1 (Commit) | Lock participants, prevent equivocation |
| 2 (Contribute) | Provide masked shares for aggregation |

This matches Ringtail's optimal round complexity for threshold signatures without trusted setup.

### Why Message-Independent Commits?

Committing before the message is fixed prevents:

1. **Selective participation**: Attacker can't choose to participate only for favorable messages
2. **Equivocation attacks**: Same party can't sign different messages with same commitment

## Backwards Compatibility

This protocol produces **standard Lamport signatures** as defined in LP-4105. The on-chain verifier is unchanged:

```solidity
// Same verification as single-signer Lamport
LamportLib.verify(message, signature, publicKey)
```

Only the off-chain signing process differs.

## Test Cases

### Test 1: Basic 2-of-3 Signing

```
Setup:
  - 3 parties generate independent shares
  - Public key computed via MPC
  
Signing:
  - Message: keccak256("test")
  - Parties 1 and 2 participate (threshold = 2)
  - Round 1: Both commit
  - Round 2: Both contribute
  - Signature aggregated via MPC
  
Verification:
  - Standard Lamport verify returns true
  - No party learned any preimage
```

### Test 2: Threshold Not Met

```
Setup:
  - 3-of-5 threshold
  - Only 2 parties participate
  
Expected:
  - Protocol aborts after timeout
  - No partial signature leaked
  - Shares remain secure for retry
```

### Test 3: Equivocation Detection

```
Setup:
  - Party attempts different commits for same session
  
Expected:
  - Second commitment rejected
  - Party excluded from session
  - Remaining parties can complete if ≥ t
```

## Reference Implementation

### Go Types

```go
// Share holds a party's random contributions
type Share struct {
    PartyID string
    R       [256][2][32]byte  // r[i][b] for each bit position
}

// Commitment for Round 1
type Commitment struct {
    PartyID   string
    SessionID [32]byte
    Hash      [32]byte  // H(sessionId || H(r[*][*]) || nonce)
    Nonce     [32]byte
}

// Contribution for Round 2 (encrypted)
type Contribution struct {
    PartyID      string
    Preimages    [256][32]byte  // r[i][bit(m,i)] for each position
    EncryptedTo  []string       // MPC node IDs
}

// ThresholdSignature is the final output
type ThresholdSignature struct {
    Signature [256][32]byte
    NextPKH   [32]byte
    Signers   []string
}
```

### Solidity Verifier

```solidity
// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.20;

import {LamportLib} from "./LamportLib.sol";

contract LamportThreshold {
    bytes32 public currentPKH;
    uint256 public nonce;
    
    event SignatureVerified(bytes32 indexed txHash, bytes32 nextPKH, uint256 nonce);
    event KeyRotated(bytes32 indexed oldPKH, bytes32 indexed newPKH);
    
    error InvalidPKH();
    error InvalidSignature();
    
    function execute(
        bytes32 safeTxHash,
        bytes32[] calldata sig,
        bytes32[2][256] calldata currentPub,
        bytes32[2][256] calldata nextPub
    ) external {
        // 1. Verify current PKH matches
        bytes32 computedPKH = LamportLib.computePKH(currentPub);
        if (computedPKH != currentPKH) revert InvalidPKH();
        
        // 2. Compute domain-separated message
        bytes32 nextPKH = LamportLib.computePKH(nextPub);
        uint256 message = LamportLib.computeThresholdMessage(
            safeTxHash,
            nextPKH,
            address(this),
            block.chainid
        );
        
        // 3. Standard Lamport verification
        if (!LamportLib.verify(bytes32(message), sig, currentPub)) {
            revert InvalidSignature();
        }
        
        // 4. Rotate key
        emit KeyRotated(currentPKH, nextPKH);
        currentPKH = nextPKH;
        nonce++;
        
        emit SignatureVerified(safeTxHash, nextPKH, nonce);
        
        // 5. Execute transaction (implementation specific)
    }
}
```

## Security Considerations

### Preimage Security

The core security property: no Lamport preimage exists at any single node until the final signature is published.

**Proof sketch**: Each `r[j][i][b]` is uniformly random and independent. The sum `Σ r[j][i][b]` is computed inside MPC. By MPC security, no party learns the output until explicitly revealed.

### Threshold Security

With `t-of-n` threshold:
- Any `t` parties can sign
- Fewer than `t` parties learn nothing about the signature
- Compromising `t-1` parties reveals no preimages

### Quantum Resistance

Security relies only on:
1. Preimage resistance of keccak256
2. Security of MPC protocol

Both are believed quantum-resistant (keccak256 provides 128-bit security against Grover's algorithm).

### Denial of Service

**Mitigation**: 
- Timeout after Round 1 if threshold not met
- Slash deposits for parties that commit but don't contribute
- Allow session restart with different participant set

### Key Reuse Prevention

1. On-chain nonce incremented with each signature
2. Used shares MUST be deleted immediately
3. Next key committed in signature message

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
